/** web3 client frontend for rock-paper-scissors as automatically generated by Alacrity. */

import {registerInit, deployParametrizedContract,
        loggedAlert, logErrorK,
        web3, userAddress,
        registerBackendHooks, renderGame, config,
        toBN, un0x, errBacK, flip, decodeParameters, confirmTransaction,
        getGame, updateGame, removeActiveGame, queueGame,
        sendTx,
        registerContract, contract, contractAt,
        renderWei, registerNetworkConfig,
        contractAbiConstructorTypes
       } from "./alacrity-runtime.mjs";
import {isValidHand, Outcome, outcomeOfHands, State,
        registerRpsBackendHooks, player0RevealContext} from "./rps-backend.mjs";

import * as Contract from "./build/contract-auto.mjs";
registerContract(Contract.contractAbi, Contract.contractCode);
import * as Config from "./config-auto.mjs";
registerNetworkConfig(Config.networkConfig);

import * as ala from "./rps.ala.js";

ala, web3, renderGame, config, isValidHand, Outcome, outcomeOfHands, State,
registerBackendHooks, registerRpsBackendHooks, player0RevealContext;

export const contractConstructorTypes = contractAbiConstructorTypes(Contract.contractAbi)

export const netDeployContract = (...parameters) =>
    deployParametrizedContract(Contract.contractCode, contractConstructorTypes, parameters)

// TODO: mark the receive as triggering the continuation if it happens.
// Hopefully, when we receive our own
//export const ctc_recv =
//    errBacK(ctc[event](...parameters, {value}))(k)

// TODO: don't confirmTransaction; instead,
// mark the txHash as something that triggers the continuation if and when we see it confirmed
// TODO: use our KontErr monad and add kError parameters everywhere.
export const ctc_send = (ctc, event, parameters, value, k) =>
    errBacK(ctc[event](...parameters, {value}))(
        txHash => confirmTransaction(txHash, k))

// TODO #72: have a general-purpose variant of that based on the abi description.
export const decodeEvent = event => {
    const topic = event.topics[0];
    const data = event.data;
    const blockNumber = event.blockNumber;
    const txHash = event.transactionHash;
    const [name, types] = topics[topic]; // TODO: handle error if no match.
    const parameters = decodeParameters(types, un0x(data));
    return {name, parameters, blockNumber, txHash}} // TODO: get value from getTransaction and/or receipt

// TODO #74: have a way to update the state of the contract each time...
//export const stateUpdate = (state, event) => {... }

// RECEIVING DATA FROM THE BLOCKCHAIN

// Given game data (from a decoded game creation event) and game (from local user storage),
// determine if the data matches the game.
// This can be produced automatically by the compiler, together with emitting events of the proper type,
// when creating a game (with or without its own contract).
// This matters especially when tracking games you issued despite deficient atomicity in web3.
//// export const gameMatches = (d, g) => {}

// Do we need this to automatically deal with player sets?
// const gamePlayers = game => {const {player0, player1} = game;return [player0, player1]}

// We probably don't need this function, though maybe it will help our code generator
// to have separate sub-data-structures, so as to avoid name clashes;
// alternatively, we could have hierarchical-variable-names?
// And/or we have syntax objects, for which we generate distinct variable names,
// and we know that some of those objects are mapped to fixed variable names in the backend;
// and we know to not abuse gensym suffixes to avoid clashes?
//
// const gameParameters = game => {
//    const {player0, player1, timeoutinBlocks, player0Commitment, wagerInWei, escrowInWei} = game;
//    return {player0, player1, timeoutinBlocks, player0Commitment, wagerInWei, escrowInWei}}

// These were useful when using a Factory. Not in the current auto backend.
//export const isGameRelevantToUser = (game, userAddress) =>
//    game.player0 == userAddress || optionalAddressMatches(game.player1, userAddress)
//export const isGameInitiator = (game, userAddress) => game.player0 == userAddress;


/** Process a game, making all automated responses that do not require user input.
    This is perhaps the heart of the algorithm.
    TODO #72: "just" pull up the contract and call the suitable continuation with the suitable context.
    TODO: file an issue so the compiler helps our code persist.
 */
// TODO: Somehow we should follow all the events related to the contract;
// because of asynchronous handling and race conditions, the thread that listens to the
// blockchain should push incoming events in order in a queue;
// an event will be dequeued whenever a suitable handler is registered;
// if no handler is registered for an event, then handling of this and subsequent events
// is blocked until a handler is indeed registered, which should properly handle race conditions.
// When the confirmed event corresponds to a message we did send, the handler will trigger the continuation.
// When the confirmed event corresponds to input from someone else, the handler will trigger the reaction.
// All registered handlers are use-once. When selecting among a sum of handlers,
// triggering one handler de-registers its rivals as well as itself.
//
// TODO: are we triggering a renderGame here when something changes, or somewhere else?
export const processGameAtHook = confirmedBlock => id => k => {
    // TODO: move the beginning of this function to a common file...
    const game = getGame(id);
    // logging("processGameAtHook", id, game)();
    if (game.state == State.Completed) { // Game already completed, nothing to do.
        updateGame(id, {isCompleted: true});
        removeActiveGame(id);
        return k();}
    if (game.player0 == userAddress &&
        game.state == State.WaitingForPlayer0Reveal &&
        !game.player0RevealTxHash) {
        const salt = game.salt;
        const hand0 = game.hand0;
        const hand1 = game.hand1;
        const context = player0RevealContext(id, hand0, hand1, game.wagerInWei, game.escrowInWei);
        if (salt && isValidHand(hand0)) {
            loggedAlert(`${context} Please sign the following transaction.`);
            return sendTx(contractAt(game.contract).player0_reveal)(salt, hand0, {})(
                txHash => {
                    updateGame(id, {player0RevealTxHash: txHash})
                    // Register txHash for confirmation? Nah, we're just polling for state change!
                    // But if we switch to event-tracking, that's where it would happen.
                    return k();},
                error => {loggedAlert(error); return k();})
        } else {
            loggedAlert(`${context} However, you do not have the salt and hand data in this client.
Be sure to start a client that has this data before the deadline.`);}} // TODO: print the deadline!
    const timeoutBlock = game.previousBlock + game.timeoutInBlocks;
    if (confirmedBlock < timeoutBlock) {
        // We haven't yet confirmed that future blocks will be > previous + timeout
        // So add the current game to the queue, if it wasn't added yet.
        queueGame(id, timeoutBlock);
        return k();}
    if (game.player0 == userAddress &&
        game.state == State.WaitingForPlayer1) {
        if (game.player0RescindTxHash) {
            return k();}
        const stakeInWei = toBN(game.wagerInWei).add(game.escrowInWei);
        loggedAlert(`Player1 timed out in game ${id},
sending a transaction to recover your stake of ${renderWei(stakeInWei)}`);
        // TODO register the event, don't send twice.
        return sendTx(contractAt(game.contract).player0_rescind)({})(
            txHash => { updateGame(id, { player0RescindTxHash: txHash }); return k(); },
            error => { loggedAlert(error); return k()})}
    if (game.player1 == userAddress &&
        game.state == State.WaitingForPlayer0Reveal &&
        !game.player1WinByDefaultTxHash) {
        const stakeInWei = toBN(game.wagerInWei).add(game.escrowInWei);
        loggedAlert(`Player0 timed out in game ${id},
sending a transaction to recover your ${renderWei(game.wagerInWei)} wager
and their ${renderWei(stakeInWei)} stake`);
        return sendTx(contractAt(game.contract).player1_win_by_default)({})(
            txHash => {
                updateGame(id, {player1WinByDefaultTxHash: txHash});
                return k()},
            flip(logErrorK)(k))}
    return k()}

// TODO #72: support for net.deploy. See in backend-manual createGame.
export const net_deploy = () => { }

/** Accept a game of given id, playing given hand.
    Assumes the game is waiting for player1 and we're authorized.
    The alerts also suppose some manual annotation on some relatively low-level code.
    TODO #72: here replace this code by the net.attach code.
    See in backend-manual acceptGame
 */
export const net_attach = () => { }

// TODO #72: move the list of topics and its initialization to common-runtime
// in initContract.
// Just build a table (per contract kind?) from event type to topics[0] code
// (and/or possibly the table back from code to name?) by walking the abi JSON.
export const topics = {}

const initBackend = k => {
    const events = Contract.contractAbi.filter(x=>x.type==="event");
    const ctc = contract.at();
    for (let i in events) {
        const event = events[i];
        const name = event.name;
        const types = event.inputs.map(x=>x.type);
        const topic = ctc[name]().options.topics[0];
        topics[topic] = [name, types];
    }
    return k()}

//registerBackendHooks({
//    processGameAtHook, decodeGameCreationEvent, decodeGameEvent,
//    gameMatches, isGameRelevantToUser, isGameInitiator, stateUpdate})

//registerRpsBackendHooks({
//    MsgType, createNewGame, acceptGame, isGameRelevantToUser})

registerInit({
    Backend: {fun: initBackend, dependsOn: ["Contract"]}})
