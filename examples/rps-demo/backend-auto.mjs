/** web3 client frontend for rock-paper-scissors as automatically generated by Alacrity. */

import {registerInit, hexToAddress, hexTo0x, checkRequirement,
        loggedAlert, merge, flip, logErrorK,
        web3, userAddress,
        registerBackendHooks, renderGame, config,
        toBN, hexToBN,
        getGame, updateGame, removeActiveGame, queueGame,
        sendTx,
        registerContract, contract, contractAt,
        renderWei, registerNetworkConfig,
        contractAbiConstructorTypes
       } from "./alacrity-runtime.mjs";
import {isValidHand, Outcome, outcomeOfHands, State,
        registerRpsBackendHooks, player0RevealContext} from "./rps-backend.mjs";

import * as Contract from "./build/contract-auto.mjs";
registerContract(Contract.contractAbi, Contract.contractCode);
import * as Config from "./config-auto.mjs";
registerNetworkConfig(Config.networkConfig);

import * as ala from "./rps.ala.js";

ala, web3, renderGame, config, isValidHand, Outcome, outcomeOfHands, State,
registerBackendHooks, registerRpsBackendHooks, player0RevealContext;

export const contractConstructorTypes = contractAbiConstructorTypes(Contract.contractAbi)

export const netDeployContract = (contractType, ...parameters) =>
    deployParametrizedContract(contractCode, contractConstructorTypes, parameters)

// TODO #72, #82: blah, use decode parameters to match a new contract,
// see that it's indeed code + params, and match the params
export const decodeGameCreationEvent = () => { }

export const MsgType = Object.freeze({
    Player0StarGame: 0,
    Player1ShowHand: 1,
    Player0Reveal: 2,
    Player0Rescind: 3,
    Player1WinByDefault: 4
});

// TODO #72: have a general-purpose variant of that based on the abi description.
export const decodeGameEvent = event => {
    const topic = event.topics[0];
    const data = event.data;
    const blockNumber = event.blockNumber;
    const txHash = event.transactionHash;
    const x = i => data.slice(2+i*64,66+i*64);
    if (topic == topics.Player1ShowHand) {
        return {msgType: MsgType.Player1ShowHand,
                player1: hexToAddress(x(0)),
                hand1: hexToBN(x(1)).toNumber(),
                blockNumber, txHash}
    } else if (topic == topics.Player0Reveal) {
        return {msgType: MsgType.Player0Reveal,
                salt: hexTo0x(x(0)),
                hand0: hexToBN(x(1)).toNumber(),
                outcome: hexToBN(x(2)).toNumber(),
                blockNumber, txHash}
    } else if (topic == topics.Player0Rescind) {
        return {msgType: MsgType.Player0Rescind,
                blockNumber, txHash}
    } else if (topic == topics.Player1WinByDefault) {
        return {msgType: MsgType.Player1WinByDefault,
                blockNumber, txHash}}
    loggedAlert(`Unrecognized topic ${JSON.stringify({topic, data, blockNumber, txHash})}`);}

// NB: None of these checkRequirement's is useful if we trust the contract.
// NB: if we are doing speculative execution of unconfirmed messages, though,
// we may still check them to avoid a switcheroo attack, whereby the adversary
// sends a transaction to create a contract, then gets a different contract confirmed,
// but you reply to the first contract.

// export const player1ShowHand = (g, msg, player1, hand1) => { }

//export const player0Reveal = (g, msg, salt, hand0, outcome) => { }

export const checkTimeout = (g, msg) =>
    checkRequirement(msg.blockNumber > g.previousBlock + g.timeoutInBlocks,
                    () => "Over-early timeout");

// TODO: this should be just calling the continuation... but the auto output needs to implement persistence!
export const player0Rescind = (g, msg) => {
    checkRequirement(g.state == State.WaitingForPlayer1,
                    () => "Invalid state");
    checkTimeout(g, msg);
    // TODO: also check that the contract did distribute the funds as it should have?
    return merge({outcome: Outcome.Player0Rescinds,
                  previousBlock: msg.blockNumber, state: State.Completed, isCompleted: true})(g);}

export const player1WinByDefault = (g, msg) => {
    checkRequirement(g.state == State.WaitingForPlayer0Reveal,
                    () => "Invalid state");
    checkTimeout(g, msg);
    // TODO: also check that the contract did distribute the funds as it should have?
    return merge({outcome: Outcome.Player1WinByDefault,
                  previousBlock: msg.blockNumber, state: State.Completed, isCompleted: true})(g);}

// TODO #72: just map events to continuations and apply to state
export const stateUpdate = (state, event) => {
    switch (event.msgType) {
    case MsgType.Player1ShowHand:
        // return player1ShowHand(state, event, event.player1, event.hand1);
        break;
    case MsgType.Player0Reveal:
        // return player0Reveal(state, event, event.salt, event.hand0, event.outcome);
        break;
    case MsgType.Player0Rescind:
        // return player0Rescind(state, event);
        break;
    case MsgType.Player1WinByDefault:
        //return player1WinByDefault(state, event)
        break;
    }}

// RECEIVING DATA FROM THE BLOCKCHAIN

// Given game data (from a decoded game creation event) and game (from local user storage),
// determine if the data matches the game.
// This can be produced automatically by the compiler, together with emitting events of the proper type,
// when creating a game (with or without its own contract).
// This matters especially when tracking games you issued despite deficient atomicity in web3.
//// export const gameMatches = (d, g) => {}

// Do we need this to automatically deal with player sets?
// const gamePlayers = game => {const {player0, player1} = game;return [player0, player1]}

// We probably don't need this function, though maybe it will help our code generator
// to have separate sub-data-structures, so as to avoid name clashes;
// alternatively, we could have hierarchical-variable-names?
// And/or we have syntax objects, for which we generate distinct variable names,
// and we know that some of those objects are mapped to fixed variable names in the backend;
// and we know to not abuse gensym suffixes to avoid clashes?
//
// const gameParameters = game => {
//    const {player0, player1, timeoutinBlocks, player0Commitment, wagerInWei, escrowInWei} = game;
//    return {player0, player1, timeoutinBlocks, player0Commitment, wagerInWei, escrowInWei}}

// These were useful when using a Factory. Not in the current auto backend.
//export const isGameRelevantToUser = (game, userAddress) =>
//    game.player0 == userAddress || optionalAddressMatches(game.player1, userAddress)
//export const isGameInitiator = (game, userAddress) => game.player0 == userAddress;


/** Process a game, making all automated responses that do not require user input.
    This is perhaps the heart of the algorithm.
    TODO #72: "just" pull up the contract and call the suitable continuation with the suitable context.
    TODO: file an issue so the compiler helps our code persist.
 */
// TODO: are we triggering a renderGame here when something changes, or somewhere else?
export const processGameAtHook = confirmedBlock => id => k => {
    // TODO: move the beginning of this function to a common file...
    const game = getGame(id);
    // logging("processGameAtHook", id, game)();
    if (game.state == State.Completed) { // Game already completed, nothing to do.
        updateGame(id, {isCompleted: true});
        removeActiveGame(id);
        return k();}
    if (game.player0 == userAddress &&
        game.state == State.WaitingForPlayer0Reveal &&
        !game.player0RevealTxHash) {
        const salt = game.salt;
        const hand0 = game.hand0;
        const hand1 = game.hand1;
        const context = player0RevealContext(id, hand0, hand1, game.wagerInWei, game.escrowInWei);
        if (salt && isValidHand(hand0)) {
            loggedAlert(`${context} Please sign the following transaction.`);
            return sendTx(contractAt(game.contract).player0_reveal)(salt, hand0, {})(
                txHash => {
                    updateGame(id, {player0RevealTxHash: txHash})
                    // Register txHash for confirmation? Nah, we're just polling for state change!
                    // But if we switch to event-tracking, that's where it would happen.
                    return k();},
                error => {loggedAlert(error); return k();})
        } else {
            loggedAlert(`${context} However, you do not have the salt and hand data in this client.
Be sure to start a client that has this data before the deadline.`);}} // TODO: print the deadline!
    const timeoutBlock = game.previousBlock + game.timeoutInBlocks;
    if (confirmedBlock < timeoutBlock) {
        // We haven't yet confirmed that future blocks will be > previous + timeout
        // So add the current game to the queue, if it wasn't added yet.
        queueGame(id, timeoutBlock);
        return k();}
    if (game.player0 == userAddress &&
        game.state == State.WaitingForPlayer1) {
        if (game.player0RescindTxHash) {
            return k();}
        const stakeInWei = toBN(game.wagerInWei).add(game.escrowInWei);
        loggedAlert(`Player1 timed out in game ${id},
sending a transaction to recover your stake of ${renderWei(stakeInWei)}`);
        // TODO register the event, don't send twice.
        return sendTx(contractAt(game.contract).player0_rescind)({})(
            txHash => { updateGame(id, { player0RescindTxHash: txHash }); return k(); },
            error => { loggedAlert(error); return k()})}
    if (game.player1 == userAddress &&
        game.state == State.WaitingForPlayer0Reveal &&
        !game.player1WinByDefaultTxHash) {
        const stakeInWei = toBN(game.wagerInWei).add(game.escrowInWei);
        loggedAlert(`Player0 timed out in game ${id},
sending a transaction to recover your ${renderWei(game.wagerInWei)} wager
and their ${renderWei(stakeInWei)} stake`);
        return sendTx(contractAt(game.contract).player1_win_by_default)({})(
            txHash => {
                updateGame(id, {player1WinByDefaultTxHash: txHash});
                return k()},
            flip(logErrorK)(k))}
    return k()}

// TODO #72: support for net.deploy. See in backend-manual createGame.
export const net_deploy = () => { }

/** Accept a game of given id, playing given hand.
    Assumes the game is waiting for player1 and we're authorized.
    The alerts also suppose some manual annotation on some relatively low-level code.
    TODO #72: here replace this code by the net.attach code.
    See in backend-manual acceptGame
 */
export const net_attach = () => { }

// TODO #72: move the list of topics and its initialization to common-runtime
// in initContract.
// Just build a table (per contract kind?) from event type to topics[0] code
// (and/or possibly the table back from code to name?) by walking the abi JSON.
export const topics = {}

const initBackend = k => {
    const events = Contract.contractAbi.filter(x=>x.type==="event");
    const ctc = contract.at();
    for (let i in events) {
        const event = events[i];
        const name = event.name;
        const types = event.inputs.map(x=>x.type);
        console.log(i, event, name, types);
        const topic = ctc[name]().options.topics[0];
        topics[topic] = [name, types];
    }
    return k()}

//registerBackendHooks({
//    processGameAtHook, decodeGameCreationEvent, decodeGameEvent,
//    gameMatches, isGameRelevantToUser, isGameInitiator, stateUpdate})

//registerRpsBackendHooks({
//    MsgType, createNewGame, acceptGame, isGameRelevantToUser})

registerInit({
    Backend: {fun: initBackend, dependsOn: ["Contract"]}})
