# Alacrity

Alacrity is a domain-specific language for trustworthy distributed
applications. It uses a cascading style of verification with
guarantees about program execution, compilation, correctness,
security, and efficiency. It uses a suite of verification methods,
like type theory, theorem proving, model checking, the strand spaces
method, and dynamical system simulation.

### License

This code is being developed as free software by LegiLogic, Inc., for
the sake of Alacris, Ltd., that owns the copyright and publishes the
code.

The Alacrity software is distributed under the GNU Lesser General
Public License, version 2.1. See the file [LICENSE](LICENSE).

### Design and Terminology

In the space of verified distributed software, there are a large
number of terms with similar and overlapping meanings. We use the
following terms in Alacrity:

A **message** is a term generated by a free algebra involving atomic
values (like strings, bytes, numbers, and keys), concatenation, and
encryption. We may express this as a type:

```
Msg := Const Atom | Concat Msg Msg | Encrypt Msg Key
```

We abstract different cryptographic functions as particular kinds of
keys. For example: a symmetric encryption is a key that is its own
decryptor; a one-way hash is encryption with a key that has no
inverse; an asymmetric encryption has a pair of keys that are related
by the `inverse` operation; and so on. Messages are intrinsically
serializable to concrete bytes.

A **blockchain** is a unique ordered list of messages that is
common knowledge and globally authoritative. Alacrity is not a
blockchain; it uses existing blockchains. The minimal API Alacrity
expects from a blockchain is:

```
data Chain = Genesis | Closed Msg Chain

current : () -> Chain

post : Msg -> Boolean
```

That is, Alacrity only expects that a blockchain provides the ability
to observe the history of the chain (`current`) and attempt to post a
message to chain (`post`). We refer to this posting process as
*execution*. Some blockchains may in fact provide more functionality
than this, such as the ability for message sequences to observe
properties like balancing and so on. Alacrity implementations (such as
compilers specific to particular blockchains) may make use of these
features, as an optimization, but we intentionally choose a
lowest-common denominator perspective on blockchains.

A **distributed application** is a collection of _participants_ that post
to a _blockchain_ to collaboratively implement some functionality. These
participants agree on a _protocol_.

A **protocol** is the language of _messages_ that the set of
_participants_ in a _distributed application_, as well as an
interpretation of the messages.  By "interpretation of the messages",
we mean an abstract type that represents the meaning of the chain. For
example, this type might be an account ledger (a mapping of account
names to balances.)  We may express this as a type:

```
Protocol State := {
 valid_msg_p : Msg -> Boolean;
 init        : State
 observe     : State x Msg -> State
}
```

In this type, we represent the set of valid messages for a protocol as
a predicate that determines membership in the set, `valid_msg_p`. Part
of the Alacrity DSL is a specification language for these valid
message sets that is guaranteed to produce computable membership
functions, with desirable properties, such as the ability to determine
membership without access to secret keys. (Do not think this means
that we guarantee we can break all encryption; instead, if an Alacrity
programs attempts to define a message set that relies on secret
information, then it is statically rejected.)

Our representation of the interpretation is similarly subtle. It is
plausible to use a representation such as `interp : Chain ->
State`. This is problematic because it means that the interpretation
of `Closed m1 c0` can be arbitrarily different from the interpretation
of `c0`. This means, for example, that a message in the future can
cause a message in the past to have a completely different effect. Our
representation (as a catamorphism) guarantees that there is a unique
interpretation of every chain that is independent of the future. Like
with `valid_msg_p`, Alacrity guarantees that `observe` is computable
and deterministic.

XXX The discussion above implies that protocols can see the contents
of encrypted messages, even without their key inverses, because
messages are described abstractly. This could be true, but it would
put a huge constraint on the functions in the type of a protocol and
asks a lot from the blockchain. Since we don't intend for this to be
true, then we should describe messages differently to not create this
confusion.

From the perspective of Alacrity, the state of a protocol is
universally available. In other words, it is public knowledge without
access to secret information held only by participants. By analogy,
this is like how in a blockchain like Bitcoin, it is trivial to find
out the wallet with the largest amount of Bitcoin
(`385cR5DM96n1HvBDMzLHPYcw89fZAXULJP` as of March 2019.)

